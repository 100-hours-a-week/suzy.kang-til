# 시스템 아키텍처 설계의 개요

## 고수준의 설계
(세세한 내용을 다 설계하기보다, 전체적인 그림 큰 틀을 설계)

### 주요 요소
- 컴포넌트 (Components)
- 인터페이스 (Interfaces)
- 데이터 흐름 (Data Flow)
- 구성 요소 간의 관계 (Relationships)

## 아키텍처의 중요성

### 성능 최적화
- 시스템의 자원을 효율적으로 관리
- 캐시, 비동기
- 캐시 주기를 조정하자

### 확장성을 고려
- MSA 개별 서비스의 독립적인 확장 고려
- 트위터 (MSA 환경 고려 x, MSA를 빨리 도입해서 개선, DB 분산, 서비스 쪼개기 등)
- 확장성에 관한건 항상 열어두자

### 유지보수를 위해
- 문제를 신속하게 진단하고 해결하는데 도움
- 다른 모듈에 영향을 주지 않고 문제가 있는 부분에 업데이트 가능
- 모든 기술엔 트레이드오프가 있음. 장단점이 있음
- MSA에는 다양한 언어, 프레임워크를 쓰기도 하는데, 겪는 문제가 달라서 관리 유지 포인트가 늘어날 수 있음

💡 기술을 공부할 때 장단점을 생각하자.

### 시스템 안정성 신뢰성
- E2E, 단위 테스트 등 테스트 퀄리티를 높일 수 있음
- 장애 대비 (예시로 카카오: IDC(데이터 센터))
- 서버 분리, 전력 공급 장치 이중화, 페이로드

### 비용 절감
- 아키텍처가 잘 설계되어있으면 개발 비용이 절감될 수 있음
- 운영 비용이 절감됨

## 아키텍처 스타일

### 모놀리식 아키텍처
- 일반적으로 사용이 많이 되는 아키텍처 스타일
- 단일 코드 베이스
- 프론트나 백엔드 정도만 분리
- 모든 구성요소가 하나로 통합되어 있는 애플리케이션
- 강한 결합도
- 단일 배포 단위
- 작은 변경 사항이 있어도 어플리케이션이 다 배포 되어야 함
- 요즘은 MSA에 가깝게 하려고 함

#### 장점
- 기술 스택 일관성을 유지할 수 있음
- 단순한 개발과 배포
- 통합 테스트가 용이함

#### 단점
- 유지보수의 어려움
- 확장성에 대한 제한
- 배포 리스크 (전체를 배포해야하니 오래걸리고 리스크가 커질 수 있음)

#### 적용 예시
- 스타트업이나 소규모 프로젝트에서 많이 사용
- 빠른 시장 출시 필요할 때
- 일관된 환경이 필요할 때
- 통합된 시스템이 필요할 때

### 클라이언트 서버 아키텍처 (3-Tier)
- 모놀리식 아키텍처 하위에 있다고 생각하면 됨
- 클라이언트-서버 간에 작업을 분리하는 소프트웨어 구조

#### 장점
- 중앙 집중화
- 모놀리식보다 유지보수 용이성
- 확장성
- 안정성 및 신뢰성

### 마이크로서비스 아키텍처 (MSA)
- 작은 서비스들로 나누어 개발하는 소프트웨어 설계 방식
- 요즘은 MSA를 하더라도 기술 스택은 동일하게 가져가는 경우가 많아짐
- 서비스 단위로 쪼개지고, 도메인으로 쪼개지고 따로 배포를 할 수 있어야 하는 정도가 MSA 기본 단위
- API gateway가 알아서 요청 분리해줌
- 보통 RESTful API 통해 서로 통신, 메시지 브로커를 통해도 통신
- 느긋한 결합

#### 구성 요소
- 독립적인 서비스
- API 게이트웨이
- 서비스 간 통신
- 데브옵스 도구 (컨테이너화 도구, CI/CD 파이프라인, 오케스트레이션 도구 등)

#### 장점
- 확장에 용이
- 유지보수 용이성
- 개발속도가 향상

#### 단점
- 복잡한 관리 (일관성 유지하는게 어려움)
- 분산된 데이터 관리
- 배포 복잡성

### 서버리스 아키텍처
- 개발자가 서버 관리와 확장 문제를 신경쓰지 않고 비즈니스 로직에 집중할 수 있도록 하는 클라우드 컴퓨팅 모델
- FaaS (Function as a Service)

#### 구성요소
- 함수: 서버리스 아키텍처의 핵심 구성 요소
- 트리거
- API 게이트웨이
- 데이터 저장소

#### 장점
- 사용한만큼 비용을 지불하기 때문에, 자원을 효율적으로 사용할 수 있음
- 트래픽 불규칙할 때 유리함 → 자동으로 확장
- 쉬운 관리
- 빠른 배포

#### 단점
- 실행 시간 제한 → 서버리스 플랫폼은 최대 실행 시간을 제한함
- 상태 관리가 어려움 (서버리스 함수는 상태를 유지할 수 없음)
- 디버깅 및 모니터링 어려움이 있음

#### 적용사례
- 이벤트 기반 애플리케이션
- 빠른 프로토타입 MVP 개발
- 마이크로 서비스의 일부로 사용하기도 함
- 스케일 아웃이 중요한 작업에서 사용

## 아키텍처 설계 과정

### 요구사항 분석
#### 요구사항 문서화
- 요구사항 명세서
- 사용자 스토리
- 기능 명세서

#### 사용자 스토리 예시
- As a [user], I want [기능] so that [목표/이유]
- As a customer, I want to be able to search for products so that I can easily find the products I want to buy

### 시스템 모듈 분할
- 응집도를 높이고 결합도는 낮추기
- 모듈과 역할과 책임을 명확하게 함

#### 방법
- 기능적 분할
- 계층적 분할
- 도메인 기반 분할

### 컴포넌트 간 인터페이스 정의
- RESTful API
- gRPC

### 아키텍처 선택
- 요구사항에 대한 적합한 아키텍처 패턴 선택
- 아키텍처를 잘 선택하는 것은 성공을 좌우함

## 시스템 모델링

### 유스케이스 다이어그램
- 시스템과 사용자의 상호작용을 시각적으로 표현
- 누가 시스템 이용하고 접근할 수 있는지

#### 구성 요소
- 액터 (사용자, 시스템, API 등)
- 유스케이스
- 시스템 경계

### 클래스 다이어그램
- 시스템 클래스 구조를 정의하고 각 클래스의 속성과 메서드 클래스 간의 관계를 설명

### 시퀀스 다이어그램
- 팀 프로젝트 할 때 추천

### 데이터 흐름 다이어그램

### 상호작용 다이어그램
- 객체 간의 상호작용과 메세지 흐름을 상세히 모델링하여 시스템의 동작을 명확히 함
- 시퀀스랑 비슷

## 시스템 설계 원칙
- 모듈화: 시스템을 독립적인 기능 단위로 나누어 관리하는 것을 의미
- 재사용성: 기존에 개발한 모듈이나 기능을 새로운 작업을 할 때 반복적으로 사용하는 것을 의미
- 결합도: 모듈간의 의존성 정도를 말함, 낮을 수록 좋다
- 응집도: 모듈 내의 구성요소들이 얼마나 밀집해있는지 정도를 말함, 높을 수록 좋다
- 확장성: 시스템이 데이터, 트래픽, 기능 요구 증가에 대한 대응하는 능력
- 유연성: 시스템이 변화하는 요구사항에 적응할 수 있는 능력

## DevOps
- Development + Operations
- 개발팀과 운영을 통합하는 문화와 실천 방식을 의미

### 도구와 기술
- 버전 관리: Git GitHub
- CI/CD: Jenkins, GitLab CI, Circle CI
- 컨테이너화: Docker, Kubernetes
- 구성관리: Ansible, Puppet, Chef
- 모니터링: Prometheus, Grafana, ELK Stack
- 클라우드 플랫폼: AWS, Azure, Google Cloud Platform

### CI/CD
- 자동화 된 배포 프로세스